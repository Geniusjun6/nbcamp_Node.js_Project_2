# 환경변수

- .env 파일에 어떤 환경변수가 추가되어야 하는지 작성합니다.
- key=value 형태에서 key만 나열합니다. value는 비밀!

1.  Sequelize 연결 시

- MYSQL_USERNAME
- MYSQL_PASSWORD
- MYSQL_DATABASE
- MYSQL_HOST

2. JWT 토큰 Secretkey

- SECRET_KEY

# API 명세서 URL

- https://docs.google.com/spreadsheets/d/1sISX5b7Z7kYUBQN_pU6y0ge4c3dik1KVrYoy5AbeVKk/edit?usp=sharing

# ERD URL

- https://dbdiagram.io/d/nbcamp_Project_2-6551dc797d8bbd64650e4997

# 더 고민해 보기

1. **암호화 방식**

- 비밀번호를 DB에 저장할 때 Hash를 이용했는데, Hash는 `단방향 암호화`와 `양방향 암호화` 중 어떤 암호화 방식에 해당할까요?

  Hash는 단방향 암호화 방법입니다.
  단방향 암호화는 평문을 암호화 할 수는 있지만 암호문을 평문으로 복호화 할 수는 없습니다.
  또한 입력된 임의의 길이 데이터 값을 고정된 길이의 데이터로 맵핑하는 형식인데 알고리즘에 따라 길이가 다릅니다.

  이번 프로젝트에서는 bcrypt 라이브러리를 사용하였는데 'Blowfish' 알고리즘을 기반으로 한다고 합니다.

  또한 회원가입 후 DB에 비밀번호를 저장할 때 솔트를 사용하여 비밀번호는 솔트값과 함께 해싱되어 저장되고, 같은 비밀번호라고 할지라도 매번 다른 솔트값이 해싱됩니다.
  로그인 시에는 저장된 솔트를 사용하여 입력된 비밀번호를 해시합니다.

  \*\* 회원가입 시 코드
  bcrypt.genSalt(10);
  bcrypt.hash(user.password, salt);

  \*\* 로그인 시 코드
  bcrypt.compare(password, user.password);

- 비밀번호를 그냥 저장하지 않고 Hash 한 값을 저장 했을 때의 좋은 점은 무엇인가요?

  해시된 값을 DB에 저장할 경우 DB가 유출되더라도 보안에 상대적으로 안전합니다.
  다만, 해커들이 무차별적으로 임의의 값을 입력하면 입력된 값을 알아낼 수 있다고 합니다. (보완하기 위해 Salt를 진행하긴 하지만..)

2. **인증 방식**

- JWT(Json Web Token)을 이용해 인증 기능을 했는데, 만약 Access Token이 노출되었을 경우 발생할 수 있는 문제점은 무엇일까요?

  토큰을 획득한 사람이 해당 토큰 발급 대상으로 인증을 시도할 수 있습니다.
  즉 노출된 토큰의 아이디로 로그인을 할 수 있습니다.

- 해당 문제점을 보완하기 위한 방법으로는 어떤 것이 있을까요?

  - HTTPS 통신을 사용 : 암호화된 통신을 사용하여 보안을 강화 한다.
  - Refresh Token 사용 : Access Token의 유효기간을 짧게 설정하고, 갱신을 위한 Refresh Token을 사용합니다.

3. **인증과 인가**

- 인증과 인가가 무엇인지 각각 설명해 주세요.

  - 인증 : 사용자가 시스템에 대해 자신을 식별하는 과정으로 사용자가 누구인지 확인하고, 사용자가 제공한 정보가 정확한지 검증합니다.
  - 인가 : 사용자에 대한 권한을 부여하고 특정 자원이나 서비스에 접근할 수 있는 권한을 경정하는 과정입니다.

- 과제에서 구현한 Middleware는 인증에 해당하나요? 인가에 해당하나요? 그 이유도 알려주세요.
  - 과제에서는 인가에 해당한다고 생각합니다. 이유는 로그인 시에 발급한 토큰을 확인하여 내 정보 조회, 상품등록, 상품조회 등을 할 수 있도록 권한을 주는 역할을 합니다.

4. **Http Status Code**

- 과제를 진행하면서 `사용한 Http Status Code`를 모두 나열하고, 각각이 `의미하는 것`과 `어떤 상황에 사용`했는지 작성해 주세요.

  **<회원가입>**

  [코드 400] : 잘못된 요청할 경우

  - 이메일 형식이 아닐경우
  - 패스워드가 6자 미만일 경우

  [코드 401] : 미승인 (비인증)

  - password와 confirmPassword가 다른 경우

  [코드 201] : 요청 성공 - 새로운 리소스 생성

  - 유효성 검사를 모두 통과하여 신규 인원 생성

  [코드 500] : 예기치 못한 에러가 발생되었을 때

  - 위 유효성 검사 외 에러

  **<로그인>**

  [코드 401] : 미승인 (비인증)

  - 이메일 및 비밀번호가 일치하지 않을 경우

  [코드 200] : 요청이 성공적으로 완료

  - 로그인이 성공되었을 때

  [코드 500] : 예기치 못한 에러가 발생되었을 때

  - 위 유효성 검사 외 에러

  **<미들웨어>**

  [코드 401] : 미승인 (비인증)

  - 토큰 사용자가 존재하지 않을 경우
  - 토큰 타입이 불일치 할 경우
  - 토큰의 유효기간이 만료된 경우

  **<상품등록>**

  [코드 400] : 요청이 서버에서 처리할 수 없거나 형식을 이해할 수 없을 때

  - 입력된 데이터 형식이 올바르지 않을 경우
  - 요청하는 입력 데이터를 모두 입력하지 않았을 경우

  [코드 201] : 요청 성공 - 새로운 리소스 생성

  - 새로운 상품 등록

  [코드 500] : 예기치 못한 에러가 발생되었을 때

  - 위 유효성 검사 외 에러

  **<상품조회>**

  [코드 200] : 요청이 성공적으로 완료

  - 상품이 정상적으로 조회되었을 때 (상품이 없는 경우 포함)

  [코드 500] : 예기치 못한 에러가 발생되었을 때

  **<상품 상세조회>**

  [코드 404] : 요청받은 리소스를 찾을 수 없을 때

  - 상품을 찾을 수 없을 때

  [코드 200] : 요청이 성공적으로 완료

  - 상품이 정상적으로 조회되었을 때

  [코드 500] : 예기치 못한 에러가 발생되었을 때

  **<상품 수정>**

  [코드 404] : 요청받은 리소스를 찾을 수 없을 때

  - 상품을 찾을 수 없을 때

  [코드 403] : 미승인 (사용자가 누구인지 알 경우)

  - 작성한 상품이 본인 것이 아닐 경우

  [코드 200] : 요청이 성공적으로 완료

  - 상품이 정상적으로 수정 되었을 때

  [코드 400] : 요청이 서버에서 처리할 수 없거나 형식을 이해할 수 없을 때

  - 수정한 상품 내용이 설정한 FOR_SALE / SOLD_OUT 외에 다른 내용일 때

  [코드 500] : 예기치 못한 에러가 발생되었을 때

  **<상품 삭제>**

  [코드 404] : 요청받은 리소스를 찾을 수 없을 때

  - 상품을 찾을 수 없을 때

  [코드 401] : 미승인 (비인증)

  - 작성한 상품이 본인 것이 아닐 경우

  [코드 500] : 예기치 못한 에러가 발생되었을 때

5. **리팩토링**

- MongoDB, Mongoose를 이용해 구현되었던 코드를 MySQL, Sequelize로 변경하면서, 많은 코드 변경이 있었나요? 주로 어떤 코드에서 변경이 있었나요?

  - 코드 변경이 많이 되지 않았다고 생각합니다.
    크게 2가지로 데이터의 형식을 정하는 스키마(모델)를 지정할 때의 명령어?와 만든 모델에서 사용 가능한 메서드들이 달라졌습니다.

- 만약 이렇게 DB를 변경하는 경우가 또 발생했을 때, 코드 변경을 보다 쉽게 하려면 어떻게 코드를 작성하면 좋을 지 생각나는 방식이 있나요? 있다면 작성해 주세요.

  - 동일한 기능 (특정 상품을 찾는 부분)은 함수 형식으로 관리하여 DB변경 시 해당 문법에 맞게만 고치면 좋을 것 같습니다.

6. **서버 장애 복구**

- 현재는 PM2를 이용해 Express 서버의 구동이 종료 되었을 때에 Express 서버를 재실행 시켜 장애를 복구하고 있습니다. 만약 단순히 Express 서버가 종료 된 것이 아니라, AWS EC2 인스턴스(VM, 서버 컴퓨터)가 재시작 된다면, Express 서버는 재실행되지 않을 겁니다. AWS EC2 인스턴스가 재시작 된 후에도 자동으로 Express 서버를 실행할 수 있게 하려면 어떤 조치를 취해야 할까요?
  (Hint: PM2에서 제공하는 기능 중 하나입니다.)

  - PM2에서 제공하는 기능 중 startup 이라는 명령어가 있습니다. 시스템 부팅 시 PM2가 자동으로 실행되도록 하는 기능입니다.
    사용하기 위해서 pm2 save를 이용해 실행중인 PM2 프로세스 목록이 저장해야 합니다.

7. **개발 환경**

- nodemon은 어떤 역할을 하는 패키지이며, 사용했을 때 어떤 점이 달라졌나요?

  - Nodemon은 디렉토리의 파일이 변경되는 것을 감지하여 노드 애플리케이션을 자동으로 다시 시작해주는 도구 입니다.
  - 기존에는 ctrl+c를 이용해 서버를 끄고 명령어를 입력해 다시 서버를 실행했는데, nodemon을 사용하면서는 저장만 누르면 됩니다.

- npm을 이용해서 패키지를 설치하는 방법은 크게 일반, 글로벌(`--global, -g`), 개발용(`--save-dev, -D`)으로 3가지가 있습니다. 각각의 차이점을 설명하고, nodemon은 어떤 옵션으로 설치해야 될까요?

  - 일반 설치 : 패키지를 현재 프로젝트 로컬에 설치합니다. 따라서 해당 프로젝트 내에서만 사용 가능합니다.
  - 글로벌 설치 : 패키지를 시스템 전역에 설치하여 어느 터미널에서든 사용이 가능합니다.
  - 개발용 설치 : 개발 중에만 필요한 패키지 입니다. package.json 파일의 'devDependencies' 에 기록되어 배포할 때는 설치되지 않습니다.

  - 따라서 nodemon은 개발용으로 설치하는 것이 적절합니다.
